import fitz  # PyMuPDF
import os
import cv2
import pandas as pd
from openpyxl import Workbook
from openpyxl.drawing.image import Image



def extract_images_from_pdf(pdf_path, output_folder):
    """
    Extracts images from a PDF and saves them to the output folder.
    """
    pdf_document = fitz.open(pdf_path)
    os.makedirs(output_folder, exist_ok=True)
    image_paths = []

    for page_num in range(len(pdf_document)):
        page = pdf_document[page_num]
        image_list = page.get_images(full=True)
        for img_index, img in enumerate(image_list):
            xref = img[0]
            base_image = pdf_document.extract_image(xref)
            image_bytes = base_image["image"]
            image_ext = base_image["ext"]
            image_output_path = os.path.join(output_folder, f"page{page_num + 1}_img{img_index + 1}.{image_ext}")
            with open(image_output_path, "wb") as img_file:
                img_file.write(image_bytes)
            image_paths.append(image_output_path)
            print(f"Extracted image saved to: {image_output_path}")

    return image_paths


def process_graph_image(image_path):
    """
    Processes a graph image to extract data (e.g., bar heights).
    """
    image = cv2.imread(image_path)
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Threshold the image to isolate graphical elements
    _, binary = cv2.threshold(gray, 150, 255, cv2.THRESH_BINARY_INV)

    # Detect contours (e.g., bars in a bar chart)
    contours, _ = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    bar_data = []

    for contour in contours:
        x, y, w, h = cv2.boundingRect(contour)
        if h > 20:  # Filter small noise
            # Approximate bar height relative to the y-axis
            bar_data.append((x, h))

    # Sort data by x-coordinate for logical arrangement
    bar_data = sorted(bar_data, key=lambda item: item[0])

    # Normalize bar heights to approximate y-axis values
    max_height = max([h for _, h in bar_data]) if bar_data else 1
    y_axis_scale = 100  # Example: Adjust based on graph scale (manual input or automated detection)
    normalized_data = [(x, int((h / max_height) * y_axis_scale)) for x, h in bar_data]

    # Create a pandas DataFrame with extracted data
    df = pd.DataFrame(normalized_data, columns=["X Position", "Approx. Value"])
    return df, image



def save_to_excel(output_path, data_table, graph_image_path):
    """
    Saves the tabular data and graph image to an Excel file.
    """
    # Delete the file if it exists
    if os.path.exists(output_path):
        os.remove(output_path)

    wb = Workbook()
    ws = wb.active
    ws.title = "Graph Data"

    # Write tabular data to Excel
    for r_idx, row in enumerate(data_table.itertuples(index=False), start=1):
        for c_idx, value in enumerate(row, start=1):
            ws.cell(row=r_idx, column=c_idx, value=value)

    # Insert the graph image into Excel
    img = Image(graph_image_path)
    img.width = 300  # Adjust the width
    img.height = 200  # Adjust the height
    img.anchor = "E1"  # Place next to the table
    ws.add_image(img)

    # Save the Excel file
    wb.save(output_path)
    print(f"Data and graph saved to: {output_path}")

def main():
    pdf_path = "sample_pdfs/Sample1.pdf"  # Path to the input PDF
    output_folder = "extracted_images"   # Folder for extracted images
    excel_output_path = "output_excel/graph_data.xlsx"  # Output Excel file

    os.makedirs("output_excel", exist_ok=True)

    # Step 1: Extract images from the PDF
    images = extract_images_from_pdf(pdf_path, output_folder)

    # Step 2: Process each image
    for image_path in images:
        print(f"Processing image: {image_path}")
        data_table, graph_image = process_graph_image(image_path)

        # Step 3: Save the extracted data and graph to Excel
        save_to_excel(excel_output_path, data_table, image_path)


if __name__ == "__main__":
    main()
