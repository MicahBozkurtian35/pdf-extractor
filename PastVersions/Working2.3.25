import anthropic
import base64
import os
import io
import math
import pandas as pd
import openpyxl
import shutil
from pdf2image import convert_from_path
from PIL import Image, ImageChops
from openpyxl.drawing.image import Image as XLImage
from openpyxl.chart import BarChart, LineChart, PieChart

# New imports for OpenCV-based cropping and for working with column letters
import cv2
import numpy as np
from openpyxl.utils import get_column_letter

def read_anthropic_key(file_path=r"C:\API\anthropic_key.txt"):
    """Reads the Anthropic API key from a text file and returns it."""
    try:
        with open(file_path, "r") as f:
            api_key = f.read().strip()
            return api_key
    except Exception as e:
        print(f"Error reading Anthropic API key from {file_path}: {e}")
        return None

def crop_graph_opencv(pil_image, margin=10, extra_margin_ratio=0.5):
    """
    Crops ONLY the graph portion from an image using OpenCV edge detection
    and contour analysis, then expands the bounding box to include nearby labels.

    Steps:
      1. Convert the PIL image to a NumPy array.
      2. Convert to grayscale and apply Gaussian blur.
      3. Use Canny edge detection to detect edges.
      4. Find external contours and select the largest by area.
      5. Compute the bounding box of that contour and add a fixed margin.
      6. Expand the bounding box further by extra_margin_ratio (default 0.5)
         of the bounding box dimensions.
      7. Crop the image to that bounding box and return as a PIL image.
    """
    cv_image = np.array(pil_image)
    if cv_image.shape[-1] == 4:
        cv_image = cv2.cvtColor(cv_image, cv2.COLOR_RGBA2RGB)
    gray = cv2.cvtColor(cv_image, cv2.COLOR_RGB2GRAY)
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)
    edges = cv2.Canny(blurred, 50, 150)
    contours, _ = cv2.findContours(edges.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if not contours:
        return pil_image
    max_contour = max(contours, key=cv2.contourArea)
    x, y, w, h = cv2.boundingRect(max_contour)
    x = max(x - margin, 0)
    y = max(y - margin, 0)
    w = w + 2 * margin
    h = h + 2 * margin
    extra_w = int(w * extra_margin_ratio)
    extra_h = int(h * extra_margin_ratio)
    x = max(x - extra_w, 0)
    y = max(y - extra_h, 0)
    img_height, img_width = cv_image.shape[:2]
    x_end = min(x + w + 2 * extra_w, img_width)
    y_end = min(y + h + 2 * extra_h, img_height)
    cropped_cv = cv_image[y:y_end, x:x_end]
    cropped_pil = Image.fromarray(cropped_cv)
    return cropped_pil

def pdf_to_pngs(pdf_path, output_dir="temp_images"):
    """
    Extracts graph images from a PDF and saves them to the output folder.
    (No cropping is performed here so that the raw image is available.)
    """
    os.makedirs(output_dir, exist_ok=True)
    poppler_path = r"C:\poppler\poppler-24.08.0\Library\bin"
    images = convert_from_path(pdf_path, poppler_path=poppler_path)
    image_paths = []
    for i, image in enumerate(images):
        image_path = os.path.join(output_dir, f"chart_{i}.png")
        image.save(image_path, "PNG")
        image_paths.append(image_path)
        print(f"Extracted graph image saved to {image_path}")
    return image_paths

def extract_data_with_claude(image_path, api_key):
    """
    Extracts structured data from a chart image using Claude 3 Sonnet.
    The prompt instructs Claude to:
      - Return the CSV data.
      - Provide a ChartType line (e.g. "ChartType: Bar").
      - Provide a YAxis line with details in the format:
          YAxis: <label>, <min>, <max>, <tick>
    """
    try:
        client = anthropic.Anthropic(api_key=api_key)
        with open(image_path, "rb") as f:
            image_data = f.read()
        base64_encoded_image = base64.b64encode(image_data).decode("utf-8")
        file_extension = os.path.splitext(image_path)[1].lower()
        mime_type = {
            '.png': 'image/png',
            '.jpg': 'image/jpeg',
            '.jpeg': 'image/jpeg',
            '.gif': 'image/gif',
            '.webp': 'image/webp'
        }.get(file_extension, 'image/png')
        prompt_text = """
Be as accurate as possible and provide the tabular data from this graph in CSV format.
Additionally, determine the type of the graph (e.g., Bar, Line, Pie) and the details of the Y axis.
Include the following two lines at the start of your output:
   ChartType: <type>
   YAxis: <label>, <min>, <max>, <tick>
Then, output only the CSV data (with header and rows).
Requirements:
1. Extract EXACT numerical values from the graph.
2. Maintain all categories and periods in separate columns.
3. Do not include any extra text or explanations.
4. Use precise numbers, not approximations.

Example response:
ChartType: Bar
YAxis: Value, 100000, 300000, 100000
Category,Period 1,Period 2
A,150000,200000
B,180000,250000
"""
        response = client.messages.create(
            model="claude-3-5-sonnet-20241022",
            max_tokens=1024,
            temperature=0.0,
            messages=[
                {
                    "role": "user",
                    "content": [
                        {"type": "text", "text": prompt_text},
                        {
                            "type": "image",
                            "source": {
                                "type": "base64",
                                "media_type": mime_type,
                                "data": base64_encoded_image
                            }
                        }
                    ]
                }
            ]
        )
        response_text = response.content[0].text if response.content else ""
        chart_type = None
        y_axis_info = None
        csv_lines = []
        for line in response_text.splitlines():
            line_stripped = line.strip()
            if line_stripped.startswith("ChartType:"):
                chart_type = line_stripped[len("ChartType:"):].strip()
            elif line_stripped.startswith("YAxis:"):
                y_axis_info = line_stripped[len("YAxis:"):].strip()
            elif ',' in line_stripped:
                csv_lines.append(line_stripped)
        csv_text = "\n".join(csv_lines)
        if csv_text:
            print(f"Extracted CSV Data from {image_path}:\n{csv_text}")
            return {"csv_text": csv_text, "chart_type": chart_type, "y_axis_info": y_axis_info}
        else:
            print(f"Claude returned an empty response for {image_path}.")
            return None
    except Exception as e:
        print(f"Error processing image with Claude: {e}")
        return None

def validate_extracted_data(csv_text, expected_columns=2):
    """Validates the extracted CSV data."""
    try:
        df = pd.read_csv(io.StringIO(csv_text))
        if len(df.columns) != expected_columns + 1:
            print(f"Warning: Unexpected number of columns: {len(df.columns)}")
        return all(df.iloc[:, 1:].apply(lambda x: x.dtype in ['int64', 'float64']))
    except Exception as e:
        print(f"Validation error: {e}")
        return False

def extract_with_retries(image_path, api_key, max_retries=3):
    """Attempts to extract data multiple times if needed."""
    for attempt in range(max_retries):
        result = extract_data_with_claude(image_path, api_key)
        if result and result.get("csv_text") and validate_extracted_data(result["csv_text"]):
            return result
        print(f"Retry {attempt + 1}/{max_retries} for {image_path}")
    return None

def convert_csv_to_dataframe(csv_text):
    """Converts the CSV text to a pandas DataFrame."""
    try:
        csv_text = csv_text.strip()
        df = pd.read_csv(io.StringIO(csv_text))
        return df
    except Exception as e:
        print(f"Error converting CSV text to DataFrame: {e}")
        return None

def create_excel_tab_with_data(dataframe, excel_writer, tab_name, original_image_path, chart_type, y_axis_info):
    """
    Creates an Excel tab with:
      - The tabular data at the top-left,
      - A generated chart (recreated from the data) immediately below the table,
      - The original graph image **always placed in column J**.
      - Axis labels and values included to match the original graph.
      - The legend (key) is moved to the side of the chart.
      - Pie charts now work correctly with separate handling.
    """
    try:
        dataframe.to_excel(excel_writer, sheet_name=tab_name, index=False, startrow=1)
        workbook = excel_writer.book
        worksheet = excel_writer.sheets[tab_name]

        # Add title
        worksheet['A1'] = "Graph Analysis Results"
        worksheet['A1'].font = openpyxl.styles.Font(size=14, bold=True)

        num_data_rows = len(dataframe)
        num_data_cols = len(dataframe.columns)
        table_end_row = num_data_rows + 2
        chart_row = table_end_row + 2

        # Extract Y-axis info (if available) for proper scaling
        y_label = ""
        y_min = None
        y_max = None
        y_tick = None
        if y_axis_info:
            try:
                parts = y_axis_info.split(",")
                y_label = parts[0].strip()
                y_min = float(parts[1].strip())
                y_max = float(parts[2].strip())
                y_tick = float(parts[3].strip())
            except Exception as e:
                print(f"Error parsing Y-axis info: {e}")

        # Create the generated chart
        if chart_type and "pie" in chart_type.lower():
            chart = PieChart()
            data_range = openpyxl.chart.Reference(worksheet, min_col=2, min_row=2, max_col=2, max_row=table_end_row)
            categories = openpyxl.chart.Reference(worksheet, min_col=1, min_row=3, max_row=table_end_row)
            chart.add_data(data_range, titles_from_data=True)
            chart.set_categories(categories)
            chart.title = "Recreated Graph"
        else:
            chart = LineChart() if "line" in chart_type.lower() else BarChart()
            data_range = openpyxl.chart.Reference(worksheet, min_col=2, min_row=2, max_col=num_data_cols, max_row=table_end_row)
            categories = openpyxl.chart.Reference(worksheet, min_col=1, min_row=3, max_row=table_end_row)
            chart.add_data(data_range, titles_from_data=True)
            chart.set_categories(categories)
            chart.title = "Recreated Graph"

            # Set X-axis and Y-axis labels for non-pie charts
            if y_label:
                chart.y_axis.title = y_label
            chart.x_axis.title = dataframe.columns[0]  # Use the first column as X-axis title

            # Apply Y-axis scale if detected (Only for non-pie charts)
            if y_min is not None and y_max is not None:
                chart.y_axis.scaling.min = y_min
                chart.y_axis.scaling.max = y_max
            if y_tick:
                chart.y_axis.majorUnit = y_tick  # Set tick interval

        # Move the legend to the side to prevent overlap
        chart.legend.position = "r"  # Moves the key to the right of the chart

        worksheet[f"A{chart_row - 1}"] = "Generated Graph:"
        worksheet.add_chart(chart, f"A{chart_row}")

        # Process the original image (cropping and resizing)
        with Image.open(original_image_path) as img:
            cropped_img = crop_graph_opencv(img, margin=10, extra_margin_ratio=0.5)
            max_width = 600
            width_percent = max_width / float(cropped_img.size[0])
            new_height = int(cropped_img.size[1] * width_percent)
            resized_image = cropped_img.resize((max_width, new_height), Image.Resampling.LANCZOS)
            resized_image_path = original_image_path.replace('.png', '_resized.png')
            resized_image.save(resized_image_path)

        # **Ensure the original graph is placed in column J**
        worksheet["J" + str(chart_row - 1)] = "Original Graph:"
        worksheet.add_image(XLImage(resized_image_path), "J" + str(chart_row))

    except Exception as e:
        print(f"Error creating tab {tab_name} in Excel: {e}")

def process_pdf_to_excel(pdf_path, excel_output_path):
    """Processes a PDF, extracts chart images, analyzes them, and saves structured data to Excel."""
    try:
        api_key = read_anthropic_key()
        if not api_key:
            print("Could not authenticate with Claude API.")
            return
        image_paths = pdf_to_pngs(pdf_path)
        excel_writer = pd.ExcelWriter(excel_output_path, engine="openpyxl")
        sheet_added = False
        for image_path in image_paths:
            print(f"Processing {image_path}...")
            result = extract_with_retries(image_path, api_key)
            if result:
                csv_text = result.get("csv_text")
                chart_type = result.get("chart_type")
                y_axis_info = result.get("y_axis_info")
                dataframe = convert_csv_to_dataframe(csv_text)
                if dataframe is not None and not dataframe.empty:
                    tab_name = os.path.splitext(os.path.basename(image_path))[0]
                    create_excel_tab_with_data(dataframe, excel_writer, tab_name, image_path, chart_type, y_axis_info)
                    sheet_added = True
        if sheet_added:
            excel_writer.close()
            print(f"Excel file created: {excel_output_path}")
        else:
            print("No valid data extracted. Skipping Excel file creation.")
        shutil.rmtree("temp_images", ignore_errors=True)
    except Exception as e:
        print(f"Error processing PDF {pdf_path}: {e}")

if __name__ == "__main__":
    pdf_file_path = r"C:\Users\Mbomm\IdeaProjects\PDF Graph Scanner\input_pdfs\Sample2.pdf"
    excel_file_path = "output.xlsx"
    process_pdf_to_excel(pdf_file_path, excel_file_path)
