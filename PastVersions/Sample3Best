import anthropic
import base64
import os
import io
import xlwings as xw
import math
import pandas as pd
import openpyxl
import shutil
from pdf2image import convert_from_path
from PIL import Image
from openpyxl.drawing.image import Image as XLImage
from openpyxl.chart import PieChart, Reference
import cv2
import numpy as np
from openpyxl.utils import get_column_letter
import pdfplumber
import json
import time
import glob

# Global debug flag: set to True for verbose output.
DEBUG = True
def debug_print(*args, **kwargs):
    if DEBUG:
        print(*args, **kwargs)

#############################################
# Helper: Fix Base64 Padding
#############################################
def fix_base64_padding(s):
    return s + "=" * ((4 - len(s) % 4) % 4)

#############################################
# Helper: Remove Temporary Excel Files
#############################################
def remove_temp_excel_files(excel_path):
    directory = os.path.dirname(os.path.abspath(excel_path))
    temp_files = glob.glob(os.path.join(directory, "~$*"))
    for temp_file in temp_files:
        try:
            os.remove(temp_file)
            debug_print("Removed temporary Excel file:", temp_file)
        except Exception as e:
            debug_print("Failed to remove temporary Excel file:", temp_file, e)

#############################################
# Helper: Wait for File Lock Release
#############################################
def wait_for_file_lock_release(file_path, timeout=30):
    start_time = time.time()
    while True:
        try:
            # Try renaming the file to itself. If it fails, the file is locked.
            os.rename(file_path, file_path)
            break
        except Exception:
            time.sleep(1)
            if time.time() - start_time > timeout:
                debug_print("Timeout waiting for file lock release on", file_path)
                break

#############################################
# Basic Functions
#############################################
def read_anthropic_key(file_path=r"C:\API\anthropic_key.txt"):
    try:
        with open(file_path, "r") as f:
            return f.read().strip()
    except Exception as e:
        print(f"Error reading Anthropic API key from {file_path}: {e}")
        return None

def crop_graph_opencv(pil_image, margin=10, extra_margin_ratio=0.5):
    cv_image = np.array(pil_image)
    if cv_image.shape[-1] == 4:
        cv_image = cv2.cvtColor(cv_image, cv2.COLOR_RGBA2RGB)
    gray = cv2.cvtColor(cv_image, cv2.COLOR_RGB2GRAY)
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)
    edges = cv2.Canny(blurred, 50, 150)
    contours, _ = cv2.findContours(edges.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if not contours:
        return pil_image
    max_contour = max(contours, key=cv2.contourArea)
    x, y, w, h = cv2.boundingRect(max_contour)
    x = max(x - margin, 0)
    y = max(y - margin, 0)
    w = w + 2 * margin
    h = h + 2 * margin
    extra_w = int(w * extra_margin_ratio)
    extra_h = int(h * extra_margin_ratio)
    x = max(x - extra_w, 0)
    y = max(y - extra_h, 0)
    img_height, img_width = cv_image.shape[:2]
    x_end = min(x + w + 2 * extra_w, img_width)
    y_end = min(y + h + 2 * extra_h, img_height)
    cropped_cv = cv_image[y:y_end, x:x_end]
    return Image.fromarray(cropped_cv)

def pdf_to_pngs(pdf_path, output_dir="temp_images"):
    os.makedirs(output_dir, exist_ok=True)
    poppler_path = r"C:\poppler\poppler-24.08.0\Library\bin"
    images = convert_from_path(pdf_path, poppler_path=poppler_path)
    image_paths = []
    for i, image in enumerate(images):
        img_path = os.path.join(output_dir, f"page_{i}.png")
        image.save(img_path, "PNG")
        debug_print(f"Extracted PDF page image saved to {img_path}")
        image_paths.append(img_path)
    return image_paths

#############################################
# Graph Detection with Claude (Data Extraction Only)
#############################################
def detect_graphs_with_claude(image_path, api_key):
    with open(image_path, "rb") as f:
        image_data = f.read()
    base64_encoded_image = base64.b64encode(image_data).decode("utf-8")
    prompt = """
Please analyze the attached PDF page image and identify all graphs present.
For each graph, extract the raw graph data in CSV format that contains only the X-axis values and their corresponding Y-axis values as they appear, excluding any computed values such as standard deviations, error margins, or other derived metrics.
Determine the type of chart (e.g., Bar, Line, Pie, or a combination such as "Bar and Line", "Scatter"),
provide the Y-axis details in the format "Label,min,max,tick" as they appear,
and indicate whether the graph has a secondary Y-axis by outputting "True" or "False" in a field called "secondary_y_axis".
Also, return a bounding box for the chart area as an object with keys "left", "top", "width", "height".
Return only valid JSON in the following format (do not include any extra text):
{
  "graphs": [
    {
      "graph_number": 1,
      "csv_data": "Category,Value\\nA,150000\\nB,180000",
      "chart_type": "Bar",
      "y_axis_info": "Value,100000,300000,100000",
      "secondary_y_axis": "False",
      "bounding_box": {"left": 100, "top": 150, "width": 400, "height": 300}
    }
    // Additional graph objects...
  ]
}
"""
    try:
        client = anthropic.Anthropic(api_key=api_key)
        response = client.messages.create(
            model="claude-3-7-sonnet-20250219",
            max_tokens=2048,
            temperature=0.0,
            messages=[{
                "role": "user",
                "content": [
                    {"type": "text", "text": prompt},
                    {"type": "image", "source": {"type": "base64", "media_type": "image/png", "data": base64_encoded_image}}
                ]
            }]
        )
        raw_response = response.content[0].text
        debug_print("Raw response from Claude for", image_path, ":", raw_response)

        # Remove markdown code fences if present
        raw_response = raw_response.strip()
        if raw_response.startswith("```"):
            raw_response = raw_response.strip("`").strip()
            if raw_response.lower().startswith("json"):
                raw_response = raw_response[4:].strip()

        result_json = json.loads(raw_response)
        graphs = result_json.get("graphs", [])
        debug_print("Detected graphs in", image_path, ":", graphs)
        return graphs
    except Exception as e:
        print("Error in detect_graphs_with_claude for", image_path, ":", e)
        return []

#############################################
# CSV-to-DataFrame Conversion
#############################################
def convert_csv_to_dataframe(csv_text):
    try:
        csv_text = csv_text.strip()
        return pd.read_csv(io.StringIO(csv_text))
    except Exception as e:
        print(f"Error converting CSV text to DataFrame: {e}")
        return None

#############################################
# Data Cleaning: Remove extraneous computed columns
#############################################
def clean_dataframe(df):
    try:
        # Remove columns containing keywords like 'sd', 'std', 'error', or 'deviation'
        columns_to_keep = [col for col in df.columns if not any(kw in col.lower() for kw in ["sd", "std", "error", "deviation"])]
        return df[columns_to_keep]
    except Exception as e:
        print("Error cleaning dataframe: ", e)
        return df

#############################################
# Original Graph Cropping using pdfplumber
#############################################
def crop_chart_with_pdfplumber(pdf_path, page_image, bbox):
    base = os.path.basename(page_image)
    try:
        page_num = int(base.split('_')[1].split('.')[0])
    except Exception:
        page_num = 0
    with pdfplumber.open(pdf_path) as pdf:
        page = pdf.pages[page_num]
        left = bbox.get("left", 0)
        top = bbox.get("top", 0)
        width = bbox.get("width", page.width)
        height = bbox.get("height", page.height)
        new_top = page.height - top - height  # convert coordinate system
        crop_bbox = (left, new_top, left + width, new_top + height)
        cropped = page.crop(crop_bbox)
        return cropped.to_image(resolution=150).original

#############################################
# Excel Tab Creation (CSV Data & Original Graph)
#############################################
def create_excel_tab_with_data(dataframe, excel_writer, tab_name, chart_type, y_axis_info, secondary_y_axis, orig_img):
    try:
        dataframe.to_excel(excel_writer, sheet_name=tab_name, index=False, startrow=1)
        worksheet = excel_writer.sheets[tab_name]
        worksheet['A1'] = "Graph Analysis Results"
        worksheet['A1'].font = openpyxl.styles.Font(size=14, bold=True)
        worksheet["Z1"] = chart_type
        worksheet["Z2"] = y_axis_info
        worksheet["Z3"] = secondary_y_axis
        num_data_rows = len(dataframe) + 1
        worksheet["AA1"] = num_data_rows

        gap_row = num_data_rows + 3
        worksheet["J" + str(gap_row - 1)] = "NOTE: This program is a work in progress; graph cropping may be imperfect."
        if orig_img is not None:
            new_width = 600
            new_height = int(new_width * orig_img.height / orig_img.width)
            resized_image = orig_img.resize((new_width, new_height), Image.Resampling.LANCZOS)
            # Use BytesIO so no temp file is saved
            img_stream = io.BytesIO()
            resized_image.save(img_stream, format="PNG")
            img_stream.seek(0)
            worksheet.add_image(XLImage(img_stream), "J" + str(gap_row))
    except Exception as e:
        print(f"Error creating tab {tab_name} in Excel: {e}")

#############################################
# Chart Insertion Functions (Generated Charts)
#############################################
def map_chart_type(chart_type_val):
    if not chart_type_val:
        return None, False
    ct = chart_type_val.lower()
    # Skip unsupported chart types such as 'heat map'
    if "heat map" in ct:
        return None, False
    combo = False
    if "scatter" in ct:
        return 74, False
    if "and" in ct:
        combo = True
        return 51, combo
    else:
        if "3d" in ct:
            if "bar" in ct:
                return 15, combo
            elif "pie" in ct:
                return -4160, combo
            elif "line" in ct:
                return 65, combo
            else:
                return None, combo
        else:
            if "pie" in ct:
                return -4169, combo
            elif "bar" in ct:
                return 51, combo
            elif "line" in ct:
                return 65, combo
            else:
                return None, combo

def nice_scale(data):
    import math
    import numpy as np
    data_array = np.array(data)
    robust_min = np.percentile(data_array, 5)
    robust_max = np.percentile(data_array, 95)
    if robust_max >= 100000:
        step = 50000
    elif robust_max >= 10000:
        step = 5000
    else:
        step = 500
    new_min = math.floor(robust_min / step) * step
    new_max = math.ceil(robust_max / step) * step
    return new_min, new_max, step

def insert_nonpie_charts_xlwings(excel_output_path):
    try:
        app = xw.App(visible=False)
        wb = xw.Book(excel_output_path)
        for sheet in wb.sheets:
            chart_type_val = sheet.range("Z1").value
            # Skip pie charts â€“ they are handled separately.
            if chart_type_val and "pie" in chart_type_val.lower():
                continue
            data_range = sheet.range("A2").expand()
            if data_range.shape[0] < 2 or data_range.shape[1] < 2:
                continue
            nrows, ncols = data_range.shape
            y_axis_val = sheet.range("Z2").value
            secondary_y_axis_val = sheet.range("Z3").value
            table_end = int(sheet["AA1"].value)
            left = sheet.range("A" + str(table_end + 2)).left
            top = sheet.range("A" + str(table_end + 2)).top
            width = 350
            height = 210
            chart_obj = sheet.api.ChartObjects().Add(left, top, width, height)
            chart_com = chart_obj.Chart

            if (nrows - 1) < (ncols - 1):
                cat_range = sheet.range(data_range.address).offset(0, 0).resize(1, ncols)
                ser_range = sheet.range(data_range.address).offset(1, 0).resize(nrows - 1, ncols)
                chart_com.SetSourceData(Source=ser_range.api)
                chart_com.PlotBy = 1
                sc = chart_com.SeriesCollection()
                for i in range(1, sc.Count + 1):
                    sc.Item(i).XValues = cat_range.api
                    series_name = sheet.range("A2").offset(i, 0).value
                    sc.Item(i).Name = series_name
            else:
                cat_range = sheet.range(data_range.address).offset(1, 0).resize(nrows - 1, 1)
                ser_range = sheet.range(data_range.address).offset(1, 1).resize(nrows - 1, ncols - 1)
                chart_com.SetSourceData(Source=ser_range.api)
                chart_com.PlotBy = 2
                sc = chart_com.SeriesCollection()
                for i in range(1, sc.Count + 1):
                    sc.Item(i).XValues = cat_range.api
                    series_name = sheet.range("B2").offset(0, i - 1).value
                    sc.Item(i).Name = series_name

            excel_chart_type, combo = map_chart_type(chart_type_val)
            # If chart type is unsupported, skip chart insertion for this sheet.
            if excel_chart_type is None:
                debug_print("Unsupported chart type for sheet", sheet.name, "Skipping chart insertion.")
                continue

            chart_com.ChartType = excel_chart_type
            chart_com.HasTitle = True
            chart_com.ChartTitle.Text = "Recreated Graph"
            if excel_chart_type == 65:
                try:
                    chart_com.ChartArea.Format.ThreeD.Visible = False
                    chart_com.PlotArea.Format.ThreeD.Visible = False
                    chart_com.Rotation = 0
                    chart_com.Elevation = 0
                except Exception as e:
                    debug_print("Error disabling 3D for line chart:", e)
            if excel_chart_type not in [-4169, -4160]:
                if (nrows - 1) < (ncols - 1):
                    x_title = sheet.range(data_range.address).offset(0, 0).value
                else:
                    x_title = sheet.range("A2").value
                chart_com.Axes(1).HasTitle = True
                chart_com.Axes(1).AxisTitle.Text = x_title if x_title else "X Axis"
                chart_com.Axes(2).HasTitle = True
                if y_axis_val:
                    try:
                        parts = y_axis_val.split(",")
                        y_label = parts[0].strip() if parts else "Value"
                    except Exception as e:
                        print(f"Error parsing Y-axis info on sheet {sheet.name}: {e}")
                        y_label = "Value"
                else:
                    y_label = "Value"
                chart_com.Axes(2).AxisTitle.Text = y_label
                data_values = ser_range.value
                numeric_values = []
                if isinstance(data_values, list):
                    for row in data_values:
                        if isinstance(row, (list, tuple)):
                            for cell in row:
                                try:
                                    numeric_values.append(float(cell))
                                except Exception:
                                    pass
                        else:
                            try:
                                numeric_values.append(float(row))
                            except Exception:
                                pass
                if numeric_values:
                    new_min, new_max, major_unit = nice_scale(numeric_values)
                    try:
                        chart_com.Axes(2).MinimumScale = float(new_min)
                        chart_com.Axes(2).MaximumScale = float(new_max)
                        chart_com.Axes(2).MajorUnit = float(major_unit)
                    except Exception as e:
                        print(f"Error setting Y-axis scaling on sheet {sheet.name}: {e}")
            if str(secondary_y_axis_val).lower() == "true":
                try:
                    series_count = chart_com.SeriesCollection().Count
                    for i in range(2, series_count + 1):
                        chart_com.SeriesCollection(i).AxisGroup = 2
                    debug_print("Set series 2 to", series_count, "to secondary axis.")
                except Exception as e:
                    debug_print("Error setting secondary axis on sheet", sheet.name, ":", e)
            if combo:
                try:
                    series_count = chart_com.SeriesCollection().Count
                    chart_com.SeriesCollection(series_count).ChartType = 65
                    debug_print("Adjusted series", series_count, "to line chart for combo chart.")
                except Exception as e:
                    debug_print("Error adjusting combo chart series:", e)
        wb.save()
        wb.close()
        app.quit()
        del wb
        del app
        time.sleep(2)
        print(f"Non-pie charts inserted using xlwings in {excel_output_path}")
    except Exception as e:
        print(f"Error inserting non-pie charts with xlwings: {e}")

def insert_pie_charts_openpyxl(excel_output_path):
    try:
        from openpyxl import load_workbook
        from openpyxl.chart import PieChart, Reference
        from openpyxl.chart.label import DataLabelList
        wb = load_workbook(excel_output_path)
        for sheet in wb.worksheets:
            chart_type_cell = sheet["Z1"].value
            if chart_type_cell and "pie" in chart_type_cell.lower():
                table_end_row = sheet["AA1"].value
                if not table_end_row or int(table_end_row) < 2:
                    continue
                last_row = int(table_end_row)
                data = Reference(sheet, min_col=2, min_row=3, max_row=last_row)
                cats = Reference(sheet, min_col=1, min_row=3, max_row=last_row)
                pie = PieChart()
                pie.title = "Recreated Graph"
                pie.add_data(data, titles_from_data=False)
                pie.set_categories(cats)
                dlabels = DataLabelList()
                dlabels.showPercent = False
                dlabels.showVal = True
                dlabels.showCatName = False
                dlabels.showSerName = False
                dlabels.number_format = "General"
                pie.dataLabels = dlabels
                chart_position = "A" + str(last_row + 2)
                sheet.add_chart(pie, chart_position)
        try:
            wb.save(excel_output_path)
        except PermissionError:
            print("PermissionError: Please close the file", excel_output_path, "and try again.")
        print(f"Pie charts inserted using openpyxl in {excel_output_path}")
    except Exception as e:
        print(f"Error inserting pie charts with openpyxl: {e}")

#############################################
# Process Integration
#############################################
def process_pdf_to_excel(pdf_path, excel_output_path):
    try:
        api_key = read_anthropic_key()
        if not api_key:
            print("Could not authenticate with Claude API.")
            return
        page_images = pdf_to_pngs(pdf_path)
        all_graphs = []
        for page_image in page_images:
            print(f"Detecting graphs in {page_image}...")
            graphs = detect_graphs_with_claude(page_image, api_key)
            if graphs:
                for graph in graphs:
                    all_graphs.append((graph, page_image))
            else:
                debug_print(f"No graphs detected in {page_image}.")
        excel_writer = pd.ExcelWriter(excel_output_path, engine="openpyxl")
        sheet_added = False
        for graph_data, page_image in all_graphs:
            csv_text = graph_data.get("csv_data")
            chart_type = graph_data.get("chart_type")
            y_axis_info = graph_data.get("y_axis_info")
            secondary_y_axis = graph_data.get("secondary_y_axis", "False")
            if not csv_text:
                print(f"No CSV data for graph {graph_data.get('graph_number', 'X')}.")
                continue
            dataframe = convert_csv_to_dataframe(csv_text)
            if dataframe is None or dataframe.empty:
                continue
            # Clean the dataframe to remove extraneous computed columns
            dataframe = clean_dataframe(dataframe)
            graph_number = graph_data.get("graph_number", "1")
            tab_name = f"{os.path.splitext(os.path.basename(page_image))[0]}_graph{graph_number}"
            orig_img = None
            bbox = graph_data.get("bounding_box")
            if bbox:
                try:
                    orig_img = crop_chart_with_pdfplumber(pdf_path, page_image, bbox)
                    debug_print("Cropped original graph image using pdfplumber.")
                except Exception as e:
                    debug_print("Error cropping using pdfplumber:", e)
                    try:
                        page_img = Image.open(page_image)
                        left = bbox.get("left", 0)
                        top = bbox.get("top", 0)
                        width = bbox.get("width", page_img.width)
                        height = bbox.get("height", page_img.height)
                        orig_img = page_img.crop((left, top, left + width, top + height))
                        debug_print("Cropped original graph image using PIL fallback.")
                    except Exception as e:
                        debug_print("Error cropping using PIL fallback:", e)
            create_excel_tab_with_data(dataframe, excel_writer, tab_name, chart_type, y_axis_info, secondary_y_axis, orig_img)
            sheet_added = True
        if sheet_added:
            excel_writer.close()
            print(f"Excel file created: {excel_output_path}")
            # Remove any temporary Excel files and wait for file lock to release
            remove_temp_excel_files(excel_output_path)
            wait_for_file_lock_release(excel_output_path)
            insert_nonpie_charts_xlwings(excel_output_path)
            time.sleep(2)
            wait_for_file_lock_release(excel_output_path)
            insert_pie_charts_openpyxl(excel_output_path)
        else:
            print("No valid data extracted. Skipping Excel file creation.")
        shutil.rmtree("temp_images", ignore_errors=True)
    except Exception as e:
        print(f"Error processing PDF {pdf_path}: {e}")

if __name__ == "__main__":
    pdf_file_path = r"C:\Users\Mbomm\IdeaProjects\PDF Graph Scanner\input_pdfs\Sample3.pdf"
    excel_file_path = "output2.xlsx"
    process_pdf_to_excel(pdf_file_path, excel_file_path)
