import anthropic
import base64
import os
import io
import xlwings as xw
import math
import pandas as pd
import openpyxl
import shutil
from pdf2image import convert_from_path
from PIL import Image, ImageChops
from openpyxl.drawing.image import Image as XLImage
from openpyxl.chart import PieChart, Reference

# New imports for OpenCV-based cropping and for working with column letters
import cv2
import numpy as np
from openpyxl.utils import get_column_letter

# Global debug flag: set to True for verbose output.
DEBUG = False
def debug_print(*args, **kwargs):
    if DEBUG:
        print(*args, **kwargs)

def read_anthropic_key(file_path=r"C:\API\anthropic_key.txt"):
    """Reads the Anthropic API key from a text file and returns it."""
    try:
        with open(file_path, "r") as f:
            api_key = f.read().strip()
            return api_key
    except Exception as e:
        print(f"Error reading Anthropic API key from {file_path}: {e}")
        return None

def crop_graph_opencv(pil_image, margin=10, extra_margin_ratio=0.5):
    """
    Crops ONLY the graph portion from an image using OpenCV edge detection
    and contour analysis, then expands the bounding box to include nearby labels.
    """
    cv_image = np.array(pil_image)
    if cv_image.shape[-1] == 4:
        cv_image = cv2.cvtColor(cv_image, cv2.COLOR_RGBA2RGB)
    gray = cv2.cvtColor(cv_image, cv2.COLOR_RGB2GRAY)
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)
    edges = cv2.Canny(blurred, 50, 150)
    contours, _ = cv2.findContours(edges.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if not contours:
        return pil_image
    max_contour = max(contours, key=cv2.contourArea)
    x, y, w, h = cv2.boundingRect(max_contour)
    x = max(x - margin, 0)
    y = max(y - margin, 0)
    w = w + 2 * margin
    h = h + 2 * margin
    extra_w = int(w * extra_margin_ratio)
    extra_h = int(h * extra_margin_ratio)
    x = max(x - extra_w, 0)
    y = max(y - extra_h, 0)
    img_height, img_width = cv_image.shape[:2]
    x_end = min(x + w + 2 * extra_w, img_width)
    y_end = min(y + h + 2 * extra_h, img_height)
    cropped_cv = cv_image[y:y_end, x:x_end]
    cropped_pil = Image.fromarray(cropped_cv)
    return cropped_pil

def pdf_to_pngs(pdf_path, output_dir="temp_images"):
    """
    Extracts graph images from a PDF and saves them to the output folder.
    (No cropping is performed here so that the raw image is available.)
    """
    os.makedirs(output_dir, exist_ok=True)
    poppler_path = r"C:\poppler\poppler-24.08.0\Library\bin"
    images = convert_from_path(pdf_path, poppler_path=poppler_path)
    image_paths = []
    for i, image in enumerate(images):
        image_path = os.path.join(output_dir, f"chart_{i}.png")
        image.save(image_path, "PNG")
        debug_print(f"Extracted graph image saved to {image_path}")
        image_paths.append(image_path)
    return image_paths

def extract_data_with_claude(image_path, api_key):
    """
    Extracts structured data from a chart image using Claude 3 Sonnet.
    The prompt instructs Claude to:
      - Return the CSV data.
      - Provide a ChartType line (e.g. "ChartType: Bar").
      - Provide a YAxis line with details in the format:
          YAxis: <label>, <min>, <max>, <tick>
    """
    try:
        client = anthropic.Anthropic(api_key=api_key)
        with open(image_path, "rb") as f:
            image_data = f.read()
        base64_encoded_image = base64.b64encode(image_data).decode("utf-8")
        file_extension = os.path.splitext(image_path)[1].lower()
        mime_type = {
            '.png': 'image/png',
            '.jpg': 'image/jpeg',
            '.jpeg': 'image/jpeg',
            '.gif': 'image/gif',
            '.webp': 'image/webp'
        }.get(file_extension, 'image/png')
        prompt_text = """
Be as accurate as possible and provide the tabular data from this graph in CSV format.
Additionally, determine the type of the graph (e.g., Bar, Line, Pie) and the details of the Y axis.
Include the following two lines at the start of your output:
   ChartType: <type>
   YAxis: <label>, <min>, <max>, <tick>
Then, output only the CSV data (with header and rows).
Requirements:
1. Extract EXACT numerical values from the graph.
2. Maintain all categories and periods in separate columns.
3. Do not include any extra text or explanations.
4. Use precise numbers, not approximations.

Example response:
ChartType: Bar
YAxis: Value, 100000, 300000, 100000
Category,Period 1,Period 2
A,150000,200000
B,180000,250250
"""
        response = client.messages.create(
            model="claude-3-5-sonnet-20241022",
            max_tokens=1024,
            temperature=0.0,
            messages=[{
                "role": "user",
                "content": [
                    {"type": "text", "text": prompt_text},
                    {"type": "image", "source": {"type": "base64", "media_type": mime_type, "data": base64_encoded_image}}
                ]
            }]
        )
        response_text = response.content[0].text if response.content else ""
        chart_type = None
        y_axis_info = None
        csv_lines = []
        for line in response_text.splitlines():
            line_stripped = line.strip()
            if line_stripped.startswith("ChartType:"):
                chart_type = line_stripped[len("ChartType:"):].strip()
            elif line_stripped.startswith("YAxis:"):
                y_axis_info = line_stripped[len("YAxis:"):].strip()
            elif ',' in line_stripped:
                csv_lines.append(line_stripped)
        csv_text = "\n".join(csv_lines)
        if csv_text:
            debug_print(f"Extracted CSV Data from {image_path}:\n{csv_text}")
            return {"csv_text": csv_text, "chart_type": chart_type, "y_axis_info": y_axis_info}
        else:
            debug_print(f"Claude returned an empty response for {image_path}.")
            return None
    except Exception as e:
        print(f"Error processing image with Claude: {e}")
        return None

def validate_extracted_data(csv_text, expected_columns=2):
    """Validates the extracted CSV data."""
    try:
        df = pd.read_csv(io.StringIO(csv_text))
        if len(df.columns) != expected_columns + 1:
            print(f"Warning: Unexpected number of columns: {len(df.columns)}")
        return all(df.iloc[:, 1:].apply(lambda x: x.dtype in ['int64', 'float64']))
    except Exception as e:
        print(f"Validation error: {e}")
        return False

def extract_with_retries(image_path, api_key, max_retries=3):
    """Attempts to extract data multiple times if needed."""
    for attempt in range(max_retries):
        result = extract_data_with_claude(image_path, api_key)
        if result and result.get("csv_text") and validate_extracted_data(result["csv_text"]):
            return result
        print(f"Retry {attempt + 1}/{max_retries} for {image_path}")
    return None

def convert_csv_to_dataframe(csv_text):
    """Converts the CSV text to a pandas DataFrame."""
    try:
        csv_text = csv_text.strip()
        df = pd.read_csv(io.StringIO(csv_text))
        return df
    except Exception as e:
        print(f"Error converting CSV text to DataFrame: {e}")
        return None

def create_excel_tab_with_data(dataframe, excel_writer, tab_name, original_image_path, chart_type, y_axis_info):
    """
    Creates an Excel tab with:
      - The tabular data at the top-left,
      - (The chart will later be inserted via xlwings or openpyxl.)
      - The original graph image always placed in column G.
      - Additionally, the extracted chart type and Y-axis details are stored in hidden cell Z1 and Z2.
      - Also, the last row of the table (header plus data) is stored in cell AA1.
    """
    try:
        dataframe.to_excel(excel_writer, sheet_name=tab_name, index=False, startrow=1)
        workbook = excel_writer.book
        worksheet = excel_writer.sheets[tab_name]
        worksheet['A1'] = "Graph Analysis Results"
        worksheet['A1'].font = openpyxl.styles.Font(size=14, bold=True)
        worksheet["Z1"] = chart_type
        worksheet["Z2"] = y_axis_info
        num_data_rows = len(dataframe) + 1  # including header row
        worksheet["AA1"] = num_data_rows  # store table end row (header included)
        with Image.open(original_image_path) as img:
            cropped_img = crop_graph_opencv(img, margin=10, extra_margin_ratio=0.5)
            max_width = 600
            width_percent = max_width / float(cropped_img.size[0])
            new_height = int(cropped_img.size[1] * width_percent)
            resized_image = cropped_img.resize((max_width, new_height), Image.Resampling.LANCZOS)
            resized_image_path = original_image_path.replace('.png', '_resized.png')
            resized_image.save(resized_image_path)
        # Place original graph image in column G, below the table.
        chart_row = int(worksheet["AA1"].value) + 2
        worksheet["G" + str(chart_row - 1)] = "Original Graph:"
        worksheet.add_image(XLImage(resized_image_path), "G" + str(chart_row))
    except Exception as e:
        print(f"Error creating tab {tab_name} in Excel: {e}")

def map_chart_type(chart_type_val):
    """
    Maps the extracted chart type metadata to an Excel chart type constant.
    Returns:
      - For 2D line charts: -4101 (xlLine)
      - For 2D bar/column charts: 51 (xlColumnClustered)
      - For 2D pie charts: -4169 (xlPie)
      - For 3D bar/column charts: 15 (xl3DColumnClustered) [example]
      - For 3D pie charts: -4160 (xl3DPie) [example]
    Defaults to 2D line if ambiguous.
    """
    if not chart_type_val:
        return -4101
    ct = chart_type_val.lower()
    if "3d" in ct:
        if "bar" in ct:
            return 15
        elif "pie" in ct:
            return -4160
        elif "line" in ct:
            return -4101
        else:
            return -4101
    else:
        if "pie" in ct:
            return -4169
        elif "bar" in ct:
            return 51
        elif "line" in ct:
            return -4101
        else:
            return -4101

def insert_nonpie_charts_xlwings(excel_output_path):
    """
    Inserts non-pie charts (line/bar) using xlwings (COM API).
    For these charts, the first column (excluding header) is used as categories,
    and the series names are taken from the header row (columns B, C, etc.).
    The generated chart is placed in column A, below the table.
    """
    try:
        app = xw.App(visible=False)
        wb = xw.Book(excel_output_path)
        for sheet in wb.sheets:
            # Skip if this sheet is marked as a pie chart.
            chart_type_val = sheet.range("Z1").value
            if chart_type_val and "pie" in chart_type_val.lower():
                continue

            data_range = sheet.range("A2").expand()
            if data_range.shape[0] < 2 or data_range.shape[1] < 2:
                continue

            nrows, ncols = data_range.shape
            y_axis_val = sheet.range("Z2").value
            # Get the table end row from hidden cell AA1.
            table_end_row = sheet["AA1"].value
            left = sheet.range("A" + str(int(table_end_row) + 2)).left
            top = sheet.range("A" + str(int(table_end_row) + 2)).top
            width = 500
            height = 300
            chart_obj = sheet.api.ChartObjects().Add(left, top, width, height)
            chart_com = chart_obj.Chart
            # Determine orientation.
            if (nrows - 1) < (ncols - 1):
                # Horizontal: first row holds categories.
                cat_range = sheet.range(data_range.address).offset(0, 0).resize(1, ncols)
                ser_range = sheet.range(data_range.address).offset(1, 0).resize(nrows - 1, ncols)
                chart_com.SetSourceData(Source=ser_range.api)
                chart_com.PlotBy = 1
                sc = chart_com.SeriesCollection()
                for i in range(1, sc.Count + 1):
                    sc.Item(i).XValues = cat_range.api
                    # Set series name from first column of corresponding row (row 3 onward).
                    series_name = sheet.range("A2").offset(i, 0).value
                    sc.Item(i).Name = series_name
            else:
                # Vertical: first column is categories.
                cat_range = sheet.range(data_range.address).offset(1, 0).resize(nrows - 1, 1)
                ser_range = sheet.range(data_range.address).offset(1, 1).resize(nrows - 1, ncols - 1)
                chart_com.SetSourceData(Source=ser_range.api)
                chart_com.PlotBy = 2
                sc = chart_com.SeriesCollection()
                for i in range(1, sc.Count + 1):
                    sc.Item(i).XValues = cat_range.api
                    # Set series name from header row (row2, columns B, C, etc.)
                    series_name = sheet.range("B2").offset(0, i - 1).value
                    sc.Item(i).Name = series_name

            excel_chart_type = map_chart_type(chart_type_val)
            chart_com.ChartType = excel_chart_type
            chart_com.HasTitle = True
            chart_com.ChartTitle.Text = "Recreated Graph"
            if excel_chart_type not in [-4169, -4160]:
                if (nrows - 1) < (ncols - 1):
                    x_title = sheet.range(data_range.address).offset(0, 0).value
                else:
                    x_title = sheet.range("A2").value
                chart_com.Axes(1).HasTitle = True
                chart_com.Axes(1).AxisTitle.Text = x_title if x_title else "X Axis"
                chart_com.Axes(2).HasTitle = True
                if y_axis_val:
                    try:
                        parts = y_axis_val.split(",")
                        y_label = parts[0].strip() if parts else "Value"
                    except Exception as e:
                        print(f"Error parsing Y-axis info on sheet {sheet.name}: {e}")
                        y_label = "Value"
                else:
                    y_label = "Value"
                chart_com.Axes(2).AxisTitle.Text = y_label
        wb.save()
        wb.close()
        app.quit()
        print(f"Non-pie charts inserted using xlwings in {excel_output_path}")
    except Exception as e:
        print(f"Error inserting non-pie charts with xlwings: {e}")

def insert_pie_charts_openpyxl(excel_output_path):
    """
    Inserts pie charts using openpyxl's chart objects.
    For sheets where cell Z1 indicates a pie chart, a PieChart is created using
    the first two columns (excluding header row) and placed in column A, below the table.
    """
    try:
        from openpyxl import load_workbook
        from openpyxl.chart import PieChart, Reference

        wb = load_workbook(excel_output_path)
        for sheet in wb.worksheets:
            chart_type_cell = sheet["Z1"].value
            if chart_type_cell and "pie" in chart_type_cell.lower():
                table_end_row = sheet["AA1"].value
                if not table_end_row or int(table_end_row) < 2:
                    continue
                last_row = int(table_end_row)
                # Use columns A and B (excluding header row)
                data = Reference(sheet, min_col=2, min_row=3, max_row=last_row)
                cats = Reference(sheet, min_col=1, min_row=3, max_row=last_row)
                pie = PieChart()
                pie.title = "Recreated Graph"
                pie.add_data(data, titles_from_data=False)
                pie.set_categories(cats)
                chart_position = "A" + str(last_row + 2)
                sheet.add_chart(pie, chart_position)
        wb.save(excel_output_path)
        print(f"Pie charts inserted using openpyxl in {excel_output_path}")
    except Exception as e:
        print(f"Error inserting pie charts with openpyxl: {e}")

def process_pdf_to_excel(pdf_path, excel_output_path):
    """Processes a PDF, extracts chart images, analyzes them, and saves structured data to Excel."""
    try:
        api_key = read_anthropic_key()
        if not api_key:
            print("Could not authenticate with Claude API.")
            return
        image_paths = pdf_to_pngs(pdf_path)
        excel_writer = pd.ExcelWriter(excel_output_path, engine="openpyxl")
        sheet_added = False
        for image_path in image_paths:
            print(f"Processing {image_path}...")
            result = extract_with_retries(image_path, api_key)
            if result:
                csv_text = result.get("csv_text")
                chart_type = result.get("chart_type")
                y_axis_info = result.get("y_axis_info")
                dataframe = convert_csv_to_dataframe(csv_text)
                if dataframe is not None and not dataframe.empty:
                    tab_name = os.path.splitext(os.path.basename(image_path))[0]
                    create_excel_tab_with_data(dataframe, excel_writer, tab_name, image_path, chart_type, y_axis_info)
                    sheet_added = True
        if sheet_added:
            excel_writer.close()
            print(f"Excel file created: {excel_output_path}")
            insert_nonpie_charts_xlwings(excel_output_path)
            insert_pie_charts_openpyxl(excel_output_path)
        else:
            print("No valid data extracted. Skipping Excel file creation.")
        shutil.rmtree("temp_images", ignore_errors=True)
    except Exception as e:
        print(f"Error processing PDF {pdf_path}: {e}")

if __name__ == "__main__":
    pdf_file_path = r"C:\Users\Mbomm\IdeaProjects\PDF Graph Scanner\input_pdfs\Sample2.pdf"
    excel_file_path = "output2.xlsx"
    process_pdf_to_excel(pdf_file_path, excel_file_path)
